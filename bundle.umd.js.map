{"version":3,"file":"bundle.umd.js","sources":["src/ActionResult.js","src/Dispatcher.js","src/default-dispatcher.js","src/build-store.js","src/index.js"],"sourcesContent":["export default class ActionResult {\n\tconstructor(immediate, deferred) {\n\t\tif(deferred && !(deferred instanceof Function)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Second argument to ActionResult constructor must be a function if supplied.'\n\t\t\t);\n\t\t}\n\t\tthis.immediate = immediate;\n\t\tthis.deferred = deferred;\n\t}\n}","import ActionResult from './ActionResult';\n\nexport function Dispatcher() {\n\tlet _stores = [];\n\tconst _actionQueue = [];\n\tlet _currentAction = null;\n\n\tthis.subscribe = function(store) {\n\t\tif(!store || !store.isStore) {\n\t\t\tthrow new Error('')\n\t\t}\n\t\t_stores.push(store);\n\t};\n\n\t// Returns a Promise that resolves to true if the action was successful and false if there was\n\t// an error (recoverable or non-recoverable) thrown.\n\tthis.trigger = function(name, data = {}) {\n\t\t// Determine which stores will handle this action.\n\t\tconst stores = _stores.filter(s => s.canHandleAction(name));\n\n\t\tif(!stores.length) {\n\t\t\tthrow new Error(`There are no handlers for action \"${action}\"`);\n\t\t}\n\n\t\t// Get the immediately new state for each store\n\t\tconst results = stores.map(s => processImmediateAction(s, name, data, s.state()));\n\n\t\t// Apply the new dirty states for each store\n\t\tfor(const result of results) {\n\t\t\tif(!result.error) {\n\t\t\t\tresult.store.setState(result.state, false, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.store.setError(result.error, false);\n\t\t\t}\n\t\t\tresult.store.triggerStateChange();\n\t\t}\n\n\t\tlet returnValue = null;\n\n\t\tif(results.some(result => result.error)) {\n\t\t\treturnValue = false\n\t\t}\n\n\t\tif(!results.some(result => result.deferred)) {\n\t\t\treturnValue = true;\n\t\t}\n\n\t\tif(returnValue !== null) {\n\t\t\t// If we are waiting on anything in the queue then we also need to push this on to the\n\t\t\t// queue so that we can re-play it once the previous actions are complete.\n\t\t\tif(_actionQueue.length) {\n\t\t\t\t_actionQueue.push({\n\t\t\t\t\tname,\n\t\t\t\t\tdata,\n\t\t\t\t\tresults,\n\t\t\t\t\tresolve: null,\n\t\t\t\t\treject: null\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn returnValue;\n\t\t}\n\n\t\t// If there are deferred values to wait for then add the action to the queue \n\t\treturn new Promise((resolve, reject) => {\n\t\t\t_actionQueue.push({\n\t\t\t\tname,\n\t\t\t\tdata,\n\t\t\t\tresults,\n\t\t\t\tresolve,\n\t\t\t\treject\n\t\t\t});\n\t\t\tattemptNextActionFromQueue(_stores);\n\t\t});\n\t};\n\n\tthis.attemptNextActionFromQueue = function() {\n\t\tif(!_currentAction) {\n\t\t\t_currentAction = _actionQueue.shift();\n\t\t\tif(_currentAction) {\n\t\t\t\tthis.processActionFromQueue(_currentAction, _stores);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.processActionFromQueue = async function({ name, data, results, resolve, reject }) {\n\t\t// Determine which stores will handle this action.\n\t\tconst stores = _stores.filter(s => s.canHandleAction(name));\n\n\t\t// Get the clean state from the server for all deferred actions\n\t\tconst cleanResults = await Promise.all(results.map(processDeferredAction));\n\n\t\t// Group clean results by their store key\n\t\tconst stateByStoreKey = {};\n\t\tfor(const { state, error, store } of cleanResults) {\n\t\t\tstateByStoreKey[store.key()] = { clean: state, error, dirty: state, store };\n\t\t}\n\n\t\t// Re-apply future actions\n\t\tfor(const action of _actionQueue) {\n\t\t\t// Determine which stores will handle this action.\n\t\t\tconst stores = _stores.filter(s => s.canHandleAction(action.name));\n\n\t\t\t// Get the immediately new state for each store\n\t\t\tconst results = stores.map(\n\t\t\t\ts => processImmediateAction(s, action.name, action.data, s.state())\n\t\t\t);\n\n\t\t\t// Apply the new dirty states for each store\n\t\t\tfor(const result of results) {\n\t\t\t\tconst key = result.store.key();\n\t\t\t\tif(stateByStoreKey.hasOwnProperty(key)) {\n\t\t\t\t\tstateByStoreKey[key].dirty = result.state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the clean and dirty state for all stores and trigger updates\n\t\tfor(const key of stateByStoreKey) {\n\t\t\tconst { store, clean, dirty, error } = stateByStoreKey[key];\n\t\t\tif(!error) {\n\t\t\t\tstore.setState(clean, true, false);\n\t\t\t\tstore.setState(dirty, false, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstore.setError(error, false);\n\t\t\t}\n\t\t\tstore.triggerStateChange();\n\t\t}\n\n\t\tattemptNextActionFromQueue(stores);\n\t};\n};\n\nexport const processImmediateAction = (store, name, data, state) => {\n\tlet finalError = null;\n\tlet deferred = null;\n\ttry {\n\t\tconst result = store.handleAction(name, data, state);\n\t\tif(result instanceof ActionResult) {\n\t\t\tstate = result.immediate;\n\t\t\tdeferred = result.deferred;\n\t\t}\n\t\telse {\n\t\t\tstate = result;\n\t\t}\n\t}\n\tcatch(error) {\n\t\tif(error instanceof StoreError) {\n\t\t\tfinalError = error;\n\t\t}\n\t\telse {\n\t\t\tthrow error;\n\t\t}\n\t}\n\treturn { state, error: finalError, deferred, store };\n};\n\nexport const processDeferredAction = async (oldResult) => {\n\tlet { state } = oldResult;\n\tlet finalError = null;\n\t\n\ttry {\n\t\tif(oldResult.deferred) {\n\t\t\tstate = await oldResult.deferred();\n\t\t}\n\t}\n\tcatch(error) {\n\t\tif(error instanceof StoreError) {\n\t\t\tfinalError = error;\n\t\t}\n\t\telse {\n\t\t\tthrow error;\n\t\t}\n\t}\n\treturn { state, error: finalError, store: oldResult.store };\n};\n","import { Dispatcher } from './Dispatcher';\nexport default new Dispatcher();","import d from './default-dispatcher';\n\nexport default (actions, dispatcher = d) => {\n\tlet _key = null;\n\tconst _state = {\n\t\tclean: null,\n\t\tdirty: null\n\t};\n\tconst _components = [];\n\n\treturn class Store {\n\t\tconstructor(initialStateValue) {\n\t\t\tthis.isStore = true;\n\t\t\t_state.clean = initialStateValue;\n\t\t\t_state.dirty = initialStateValue;\n\t\t}\n\n\t\tsetKey(key) {\n\t\t\t_key = key;\n\t\t}\n\n\t\tkey() {\n\t\t\treturn _key;\n\t\t}\n\n\t\tsetState(state, clean = false, trigger = true) {\n\t\t\t_state[clean ? 'clean' : 'dirty'] = state;\n\t\t\tif(clean) {\n\t\t\t\t_state.dirty = state;\n\t\t\t}\n\n\t\t\tconst toMerge = {};\n\t\t\ttoMerge[this.key()] = _state.dirty;\n\n\t\t\tif(trigger) {\n\t\t\t\treturn this.triggerStateChange();\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tstate(clean = false) {\n\t\t\treturn _state[clean ? 'clean' : 'dirty'];\n\t\t}\n\n\t\ttriggerStateChange() {\n\t\t\treturn Promise.all(\n\t\t\t\t_components.map(c => new Promise(resolve => c.setState(toMerge, resolve)))\n\t\t\t);\n\t\t}\n\n\t\tdispatcher() {\n\t\t\treturn dispatcher;\n\t\t}\n\n\t\tcanHandleAction(name) {\n\t\t\treturn actions.hasOwnProperty(name);\n\t\t}\n\n\t\thandleAction(name, data, state) {\n\t\t\treturn actions[name].call(this, state, data);\n\t\t}\n\n\t\tconnectToState(componentKey, setStateFn) {\n\t\t\tif(!_components.some(c => c.key === componentKey)) {\n\t\t\t\t_components.push({\n\t\t\t\t\tkey: componentKey,\n\t\t\t\t\tsetState: setStateFn\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`component (key=${componentKey}) is already listening to the store ` +\n\t\t\t\t\t`(key=${this.key()})`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n};","import ActionResult from './ActionResult';\nimport buildStore from './build-store';\nimport d from './default-dispatcher';\nimport { Dispatcher } from './Dispatcher';\n\nconst init = (stores) => {\n\tfor(const key in stores) {\n\t\tconst store = stores[key];\n\t\tstore.setKey(key);\n\t\tstore.dispatcher().subscribe(store);\n\t}\n};\n\nexport {\n\tActionResult,\n\tbuildStore,\n\td,\n\tDispatcher,\n\tinit\n};"],"names":["ActionResult","immediate","deferred","Function","Error","Dispatcher","_stores","_actionQueue","_currentAction","subscribe","store","isStore","push","trigger","name","data","stores","filter","s","canHandleAction","length","action","results","map","processImmediateAction","state","result","error","setError","setState","triggerStateChange","returnValue","some","Promise","resolve","reject","attemptNextActionFromQueue","shift","processActionFromQueue","all","processDeferredAction","cleanResults","key","clean","dirty","stateByStoreKey","hasOwnProperty","finalError","handleAction","StoreError","oldResult","_context2","actions","dispatcher","d","_key","_state","_components","initialStateValue","this","c","toMerge","call","componentKey","setStateFn","setKey"],"mappings":"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"}