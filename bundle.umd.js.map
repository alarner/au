{"version":3,"file":"bundle.umd.js","sources":["src/ActionResult.js","src/stores.js","src/ids.js","src/RecoverableError.js","src/Dispatcher.js","src/default-dispatcher.js","src/build-smart-component.js","src/build-store.js","src/index.js"],"sourcesContent":["export default class ActionResult {\n\tconstructor(immediate, deferred) {\n\t\tif(deferred && !(deferred instanceof Function)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Second argument to ActionResult constructor must be a function if supplied.'\n\t\t\t);\n\t\t}\n\t\tthis.immediate = immediate;\n\t\tthis.deferred = deferred;\n\t}\n}","export default {};","class IdGenerator {\n\tconstructor() {\n\t\tthis.componentId = 1;\n\t}\n\n\tnextComponentId() {\n\t\treturn this.componentId++;\n\t}\n}\nexport default new IdGenerator();","import { Map } from 'immutable';\n\nexport default class RecoverableError extends Error {\n\tconstructor(message, key = 'default') {\n\t\tlet data = null;\n\t\tif(message instanceof RecoverableError) {\n\t\t\tdata = message.data;\n\t\t}\n\t\telse if(message instanceof Error) {\n\t\t\tdata = Map().set('default', message);\n\t\t}\n\t\telse if(typeof message === 'string') {\n\t\t\tdata = Map().set(key, message);\n\t\t}\n\t\telse {\n\t\t\tdata = Map(message);\n\t\t}\n\n\t\tmessage = '';\n\t\tjsData = data.toJS();\n\t\tfor(const key of jsData) {\n\t\t\tmessage += `${key}: ${jsData[key]}\\n`;\n\t\t}\n\n\t\tsuper(message);\n\n\t\tthis.data = data;\n\t}\n\n\ttoJS() {\n\t\treturn this.data.toJS();\n\t}\n}","import ActionResult from './ActionResult';\nimport RecoverableError from './RecoverableError';\n\nexport function Dispatcher() {\n\tlet _stores = [];\n\tconst _actionQueue = [];\n\tlet _currentAction = null;\n\n\tthis.subscribe = function(store) {\n\t\tif(!store || !store.isStore) {\n\t\t\tthrow new Error('Dispatcher.subscribe requires a store.')\n\t\t}\n\t\t_stores.push(store);\n\t};\n\n\t// Returns a Promise that resolves to true if the action was successful and false if there was\n\t// an error (recoverable or non-recoverable) thrown.\n\tthis.trigger = function(name, data = {}) {\n\t\t// Determine which stores will handle this action.\n\t\tconst stores = _stores.filter(s => s.canHandleAction(name));\n\n\t\tif(!stores.length) {\n\t\t\tthrow new Error(`There are no handlers for action \"${name}\"`);\n\t\t}\n\n\t\t// Get the immediately new state for each store\n\t\tconst results = stores.map(s => processImmediateAction(s, name, data, s.state()));\n\n\t\tlet returnValue = null;\n\n\t\tif(results.some(result => result.error)) {\n\t\t\treturnValue = false\n\t\t}\n\n\t\tif(!results.some(result => result.deferred) && _actionQueue.length === 0) {\n\t\t\treturnValue = true;\n\t\t}\n\n\t\t// Apply the new dirty states for each store\n\t\tfor(const result of results) {\n\t\t\tif(!result.error) {\n\t\t\t\tresult.store.setState(result.state, false);\n\t\t\t\t// There is no deferred piece to the result and no pending deferrec actions, so set\n\t\t\t\t// the clean state as well\n\t\t\t\tif(returnValue === true) {\n\t\t\t\t\tresult.store.setState(result.state, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.store.setError(result.error);\n\t\t\t}\n\t\t\tresult.store.triggerStateChange();\n\t\t}\n\n\t\tif(returnValue !== null) {\n\t\t\t// If we are waiting on anything in the queue then we also need to push this on to the\n\t\t\t// queue so that we can re-play it once the previous actions are complete.\n\t\t\tif(_actionQueue.length) {\n\t\t\t\t_actionQueue.push({\n\t\t\t\t\tname,\n\t\t\t\t\tdata,\n\t\t\t\t\tresults,\n\t\t\t\t\tresolve: null,\n\t\t\t\t\treject: null\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn returnValue;\n\t\t}\n\n\t\t// If there are deferred values to wait for then add the action to the queue \n\t\treturn new Promise((resolve, reject) => {\n\t\t\t_actionQueue.push({\n\t\t\t\tname,\n\t\t\t\tdata,\n\t\t\t\tresults,\n\t\t\t\tresolve,\n\t\t\t\treject\n\t\t\t});\n\t\t\tattemptNextActionFromQueue();\n\t\t});\n\t};\n\n\tconst attemptNextActionFromQueue = function() {\n\t\tif(!_currentAction) {\n\t\t\t_currentAction = _actionQueue.shift();\n\t\t\tif(_currentAction) {\n\t\t\t\tprocessActionFromQueue(_currentAction);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst processActionFromQueue = async function({ name, data, results, resolve, reject }) {\n\t\t// Determine which stores will handle this action.\n\t\tconst stores = _stores.filter(s => s.canHandleAction(name));\n\n\t\t// Get the clean state from the server for all deferred actions\n\t\tconst cleanResults = await Promise.all(results.map(processDeferredAction));\n\n\t\t// Group clean results by their store key\n\t\tconst stateByStoreKey = {};\n\t\tfor(const { state, error, store } of cleanResults) {\n\t\t\tstateByStoreKey[store.key()] = { clean: state, error, dirty: state, store };\n\t\t\tstore.setState(state, true);\n\t\t}\n\n\t\t// Re-apply future actions\n\t\tfor(const action of _actionQueue) {\n\t\t\t// Determine which stores will handle this action.\n\t\t\tconst stores = _stores.filter(s => s.canHandleAction(action.name));\n\n\t\t\t// Get the immediately new state for each store\n\t\t\tconst results = stores.map(\n\t\t\t\ts => processImmediateAction(s, action.name, action.data, s.state())\n\t\t\t);\n\n\t\t\t// Apply the new dirty states for each store\n\t\t\tfor(const result of results) {\n\t\t\t\tconst key = result.store.key();\n\t\t\t\tif(stateByStoreKey.hasOwnProperty(key)) {\n\t\t\t\t\tstateByStoreKey[key].dirty = result.state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the clean and dirty state for all stores and trigger updates\n\t\tlet hasError = false;\n\t\tfor(const key in stateByStoreKey) {\n\t\t\tconst { store, clean, dirty, error } = stateByStoreKey[key];\n\t\t\tif(!error) {\n\t\t\t\tstore.setState(clean, true);\n\t\t\t\tstore.setState(dirty, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thasError = true;\n\t\t\t\tstore.setError(error);\n\t\t\t}\n\t\t\tstore.triggerStateChange();\n\t\t}\n\n\t\tresolve(!hasError);\n\t\t_currentAction = null;\n\n\t\tattemptNextActionFromQueue(stores);\n\t};\n};\n\nexport const processImmediateAction = (store, name, data, state) => {\n\tlet finalError = null;\n\tlet deferred = null;\n\ttry {\n\t\tconst result = store.handleAction(name, data, state);\n\t\tif(result instanceof ActionResult) {\n\t\t\tstate = result.immediate;\n\t\t\tdeferred = result.deferred;\n\t\t}\n\t\telse {\n\t\t\tstate = result;\n\t\t}\n\t}\n\tcatch(error) {\n\t\tif(error instanceof RecoverableError) {\n\t\t\tfinalError = error;\n\t\t}\n\t\telse {\n\t\t\tthrow error;\n\t\t}\n\t}\n\treturn { state, error: finalError, deferred, store };\n};\n\nexport const processDeferredAction = async (oldResult) => {\n\tlet { state } = oldResult;\n\tlet finalError = null;\n\t\n\ttry {\n\t\tif(oldResult.deferred) {\n\t\t\tstate = await oldResult.deferred();\n\t\t}\n\t}\n\tcatch(error) {\n\t\tif(error instanceof RecoverableError) {\n\t\t\tfinalError = error;\n\t\t}\n\t\telse {\n\t\t\tthrow error;\n\t\t}\n\t}\n\treturn { state, error: finalError, store: oldResult.store };\n};\n","import { Dispatcher } from './Dispatcher';\nexport default new Dispatcher();","import React from 'react';\nimport stores from './stores';\nimport ids from './ids';\n\nexport default (Component, ...connectedStores) => {\n\tclass SmartComponent extends React.Component {\n\t\tconstructor(props) {\n\t\t\tsuper(props);\n\t\t\tthis.state = {};\n\t\t\tthis.key = ids.nextComponentId();\n\t\t\tfor(const key of connectedStores) {\n\t\t\t\tif(!stores.hasOwnProperty(key)) {\n\t\t\t\t\tthrow new Error(`Cannot connect component \"${Component.name}\" to non-existant store \"${key}\"`);\n\t\t\t\t}\n\t\t\t\tstores[key].connectToState(this.key, this.setState.bind(this));\n\t\t\t\tthis.state[key] = stores[key].fullState();\n\t\t\t}\n\t\t}\n\t\tcomponentWillUnmount() {\n\t\t\tfor(const key of connectedStores) {\n\t\t\t\tconnectedStores[key].ignore(this.key);\n\t\t\t}\n\t\t}\n\n\t\trender() {\n\t\t\tconst errors = {};\n\t\t\tconst values = {};\n\t\t\tfor(const key in this.state) {\n\t\t\t\terrors[key] = this.state[key].errors;\n\t\t\t\tvalues[key] = this.state[key].value;\n\t\t\t}\n\t\t\treturn (\n\t\t\t\t<Component\n\t\t\t\t\terrors={errors}\n\t\t\t\t\t{...values}\n\t\t\t\t\t{...this.props}\n\t\t\t\t/>\n\t\t\t);\n\t\t}\n\t}\n\treturn SmartComponent;\n}","import d from './default-dispatcher';\n\nexport default (actions, dispatcher = d) => {\n\tlet _key = null;\n\tconst _state = {\n\t\tclean: null,\n\t\tdirty: null\n\t};\n\tlet _components = [];\n\tlet _errors = {};\n\n\treturn class Store {\n\t\tconstructor(initialStateValue) {\n\t\t\tthis.isStore = true;\n\t\t\t_state.clean = initialStateValue;\n\t\t\t_state.dirty = initialStateValue;\n\t\t}\n\n\t\tsetKey(key) {\n\t\t\t_key = key;\n\t\t}\n\n\t\tkey() {\n\t\t\treturn _key;\n\t\t}\n\n\t\tsetState(state, clean = false) {\n\t\t\t_state[clean ? 'clean' : 'dirty'] = state;\n\t\t\tif(clean) {\n\t\t\t\t_state.dirty = state;\n\t\t\t}\n\n\t\t\tconst toMerge = {};\n\t\t\ttoMerge[this.key()] = _state.dirty;\n\t\t}\n\n\t\tstate(clean = false) {\n\t\t\treturn _state[clean ? 'clean' : 'dirty'];\n\t\t}\n\n\t\tfullState(clean = false) {\n\t\t\treturn {\n\t\t\t\tvalue: this.state(clean),\n\t\t\t\terrors: _errors\n\t\t\t}\n\t\t}\n\n\t\tsetError(error) {\n\t\t\t_errors = error.toJS();\n\t\t}\n\n\t\ttriggerStateChange() {\n\t\t\tconst toMerge = {};\n\t\t\ttoMerge[this.key()] = this.fullState();\n\t\t\treturn Promise.all(\n\t\t\t\t_components.map(c => new Promise(resolve => c.setState(toMerge, resolve)))\n\t\t\t);\n\t\t}\n\n\t\tdispatcher() {\n\t\t\treturn dispatcher;\n\t\t}\n\n\t\tcanHandleAction(name) {\n\t\t\treturn actions.hasOwnProperty(name);\n\t\t}\n\n\t\thandleAction(name, data, state) {\n\t\t\treturn actions[name].call(this, state, data);\n\t\t}\n\n\t\tconnectToState(componentKey, setStateFn) {\n\t\t\tif(!_components.some(c => c.key === componentKey)) {\n\t\t\t\t_components.push({\n\t\t\t\t\tkey: componentKey,\n\t\t\t\t\tsetState: setStateFn\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`component (key=${componentKey}) is already listening to the store ` +\n\t\t\t\t\t`(key=${this.key()})`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tignore(componentKey) {\n\t\t\t_components = _components.filter(c => c.key !== componentKey);\n\t\t}\n\t}\n};","import ActionResult from './ActionResult';\nimport buildSmartComponent from './build-smart-component';\nimport buildStore from './build-store';\nimport d from './default-dispatcher';\nimport { Dispatcher } from './Dispatcher';\nimport RecoverableError from './RecoverableError';\nimport stores from './stores';\n\nconst init = (userStores) => {\n\tfor(const key in userStores) {\n\t\tconst store = userStores[key];\n\t\tstore.setKey(key);\n\t\tstore.dispatcher().subscribe(store);\n\t\tstores[key] = store;\n\t}\n};\n\nexport {\n\tActionResult,\n\tbuildSmartComponent,\n\tbuildStore,\n\td,\n\tDispatcher,\n\tinit,\n\tRecoverableError,\n\tstores\n};"],"names":["ActionResult","immediate","deferred","Function","Error","componentId","this","RecoverableError","message","key","data","Map","set","toJS","jsData","Dispatcher","_stores","_actionQueue","_currentAction","subscribe","store","isStore","push","trigger","name","stores","filter","s","canHandleAction","length","results","map","processImmediateAction","state","returnValue","some","result","error","setError","setState","triggerStateChange","Promise","resolve","reject","attemptNextActionFromQueue","shift","processActionFromQueue","all","processDeferredAction","cleanResults","clean","dirty","action","stateByStoreKey","hasOwnProperty","hasError","finalError","handleAction","oldResult","_context2","Component","connectedStores","props","ids","nextComponentId","connectToState","_this","bind","fullState","React","ignore","errors","values","value","actions","dispatcher","d","_key","_state","_components","_errors","initialStateValue","toMerge","c","call","componentKey","setStateFn","userStores","setKey"],"mappings":"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"}